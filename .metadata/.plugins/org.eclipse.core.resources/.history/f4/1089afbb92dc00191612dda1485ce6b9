package uk.ac.ed.inf.powergrab;
import java.lang.Math;

public class Position {
	public double latitude;
	public double longitude;
		
	public Position(double latitude, double longitude) {
		this.latitude = latitude;
		this.longitude = longitude;
	}
	
	public Position() {
		latitude = 0;
		longitude = 0;
	}
	
	public Position(Position copyFrom) {
		latitude = copyFrom.latitude;
		longitude = copyFrom.longitude;
	}
	
	//TODO determine whether need calculate numbers first
	public Position nextPosition(Direction direction) {
		Position nxtPos = new Position();
		switch(direction) {
		case N: {
			nxtPos.latitude = latitude + 0.0003;
			nxtPos.longitude = longitude;
			return nxtPos;
		}
		case NNE: {
			nxtPos.latitude = latitude + Math.sin(3 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(3 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case NE: {
			nxtPos.latitude = latitude + Math.sin(2 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(2 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case ENE: {
			nxtPos.latitude = latitude + Math.sin(1 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(1 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case E: {
			nxtPos.latitude = latitude;
			nxtPos.longitude = longitude + 0.0003;
			return nxtPos;
		}
		case ESE: {
			nxtPos.latitude = latitude + Math.sin(- 1 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 1 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case SE: {
			nxtPos.latitude = latitude + Math.sin(- 2 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 2 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case SSE: {
			nxtPos.latitude = latitude + Math.sin(- 3 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 3 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case S: {
			nxtPos.latitude = latitude - 0.0003;
			nxtPos.longitude = longitude;
			return nxtPos;
		}
		case SSW: {
			nxtPos.latitude = latitude + Math.sin(- 5 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 5 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case SW: {
			nxtPos.latitude = latitude + Math.sin(- 6 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 6 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case WSW: {
			nxtPos.latitude = latitude + Math.sin(- 7 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(- 7 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case W: {
			nxtPos.latitude = latitude;
			nxtPos.longitude = longitude - 0.0003;
			return nxtPos;
		}
		case WNW: {
			nxtPos.latitude = latitude + Math.sin(7 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(7 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case NW: {
			nxtPos.latitude = latitude + Math.sin(6 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(6 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		case NNW: {
			nxtPos.latitude = latitude + Math.sin(5 / 8 * Math.PI) * 0.0003;
			nxtPos.longitude = longitude + Math.cos(5 / 8 * Math.PI) * 0.0003;
			return nxtPos;
		}
		default:
			return nxtPos;
		}
	}

	//TODO Adding change play area function
	public boolean inPlayArea() {
		if (latitude >= 55.946233) {
			return false;
		}
		if (latitude <= 55.942617) {
			return false;
		}
		if (longitude >= -3.184319) {
			return false;
		}
		if (longitude <= -3.192473) {
			return false;
		}
		return true;
	}
	
	protected void go(Direction direction) {
		Position nxtPos = nextPosition(direction);
		latitude = nxtPos.latitude;
		longitude = nxtPos.longitude;
	}
}
